var enumerate = function(fn) {return Infer({method: 'enumerate'}, fn)};
var discreteUniform = function(stepSize) {
	return uniformDraw(
		explanations.range(0, 1, (stepSize ? stepSize : 0.1))
	);
};
var probTrue = function(dist) { return probability(dist, true); };
var marginal = function(dist, value) { return enumerate(function() {sample(dist).value;}) };

// can I make this more efficient?
// https://en.wikipedia.org/wiki/Inverse_transform_sampling
// replaced with explanations.inverseCDF
var sampleWithUniformRV = function(dist, uniformRV) {
	var support = dist.support();
	var check = function(elems, probabilityMassSoFar) {
		var elemToCheck = first(elems);
		if (elems.length==1) {return elemToCheck;}
		var probabilityMass = probabilityMassSoFar + probability(dist, elemToCheck);
		if (uniformRV < probabilityMass) {
			return elemToCheck;
		} else {
			var elemsRemaining = rest(elems);
			return check(elemsRemaining, probabilityMass);
		}
	};
	check(support, 0);
};

var probability = function(dist, value) {return Math.exp(dist.score(value));};

var initializeExample = function(args) {
	var latentsModel = args.latentsModel;
	var statesModel = args.statesModel;
	var propositions = args.propositions;
	var possibleExplanations = args.possibleExplanations;
	var inferenceOptions = args.inferenceOptions;

	var counterfactualizeLatents = function(model, actual) {
		var s = 0.53; //stickiness
		var totallyDifferent = model();

		return mapObject(function(key, value) {
			return flip(s) ? actual[key] : totallyDifferent[key];
		}, actual);
	};

	var counterfactuallyIfNot = cache(function(args) {
		var actualStates = args.actualStates;
		var explanation = args.explanation;

		return Infer(
			inferenceOptions,
			function() {
				// infer latents from actual states
				// condition on counterfactual if not explanans then
				// not explanandum
				var latents = latentsModel();
				var states = statesModel(latents);
				condition(_.isEqual(states, actualStates));

				// sample a counterfactual world
				var cfLatents = counterfactualizeLatents(latentsModel, latents);
				var cfStates = statesModel(cfLatents);

				// condition on explanation being false in cfWorld
				var explanationFn = propositions[explanation];
				condition(!explanationFn(cfStates, actualStates));

				// return cfWorld
				return cfStates;
			}
		);
	});

	var marginalProposition = function(args) {
		var dist = args.dist;
		var prop = args.prop;
		var actualStates = args.actualStates;
		return enumerate(function() {
			var cfStates = sample(dist);
			var propFn = propositions[prop];
			return propFn(cfStates, actualStates);
		});
	};

	var why = function(args) {
		var actualStates = args.actualStates;
		var propositionToExplain = args.propositionToExplain;
		return function() {
			var explanation = uniformDraw(possibleExplanations);

			var cfGivenExplanationFalse = counterfactuallyIfNot({
				actualStates: actualStates,
				explanation: explanation
			});

			// get marginal over explandum proposition
			var marginal = marginalProposition({
				dist: cfGivenExplanationFalse,
				prop: propositionToExplain,
				actualStates: actualStates
			});
			// factor by probability of that explanandum being false
			factor(marginal.score(false));
			
			return _.extend(
				_.clone(actualStates),
				{explanation: explanation}
			);
		};
	};

	var forwardModel = function() {
		var latents = latentsModel();
		var states = statesModel(latents);
		return states;
	};

	return {
		forwardModel: forwardModel,
		counterfactualizeLatents: counterfactualizeLatents,
		counterfactuallyIfNot: counterfactuallyIfNot,
		why: why
	};
};
