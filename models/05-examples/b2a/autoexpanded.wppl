// ------------ explanation-related utils ----------

var stickySampler = cache(function(args) {
	var erp = args.erp;
	var origERP = args.origERP ? args.origERP : null;
	var erpLabel = args.erpLabel;

	return jsUtils.makeStickySamplingFunction(erp, origERP, erpLabel);
});

var discreteUniformERP = Infer(
	{method: "enumerate"},
	function() {
		return uniformDraw(
			_.range(0, 1, 0.05)
		);
	}
);

// var myUniform = function() {return uniform(0, 1)};
var myUniform = function() {return sample(discreteUniformERP);};

// ------------ CF prior -------------------

var structureParamsPrior = function() {
	// no CF-able structural params
	// in this program
	return {};
};

var inputPrior = function() {
	return {B: flip(0.5)};
};

var sampleParamsPrior = function() {
	return {
		A: myUniform()
	};
};

// ------------ make program -------------------

var makeProgram = function(structureParams, origERPs) {
	return function (input, sampleParams) {
	
		var B = input.B;
		
		var AERP = Bernoulli({p: (B ? 0.8 : 0.2)});
		var ASampler = stickySampler({
			erp: serializeDist(AERP),
			erpLabel: "A",
			origERP: origERPs ? serializeDist(origERPs["A"]) : null
		});
		var A = ASampler(sampleParams["A"]);
	
		return {
			ERPs: {
				A: AERP
			},
			expressions: {
				"A": A,
				"B": B
			},
			output: {
			A: A,
			B: B
		}
		};
	};
	
};



// ------------ observations -------------------

var observations = {
	structureParams: {},
	input: {},
	output: {
		A: true,
		B: true
	}
};



// ------------ forward samples -------------------

var forwardSample = function() {
	var sampleParams = sampleParamsPrior();
	var input = observations.input;
	var structureParams = observations.structureParams;
	var program = makeProgram(structureParams);
	var returnValues = program(input, sampleParams);
	var output = returnValues.output;
	return output;
};

var highOrderForwardSample = function() {
	var sampleParams = sampleParamsPrior();
	var input = inputPrior();
	var structureParams = observations.structureParams;
	var program = makeProgram(structureParams);
	var returnValues = program(input, sampleParams);
	var output = returnValues.output;
	return output;
};

// -------- explanation logic ----

var counterfactualizeLatents = function(model, actual, stickiness) {
	var s = stickiness ? stickiness : 0.53;
	var totallyDifferent = model();

	return mapObject(function(key, value) {
		return flip(s) ? actual[key] : totallyDifferent[key];
	}, actual);
};

var match = function(inferred, observed) {
	var overlappingKeys = _.object(map(function(k) {
		return [k, inferred[k]];
	}, _.keys(observed)));

	return _.isEqual(overlappingKeys, observed);
};

var counterfactual = function(stickiness, cfPremise) {
	
	// first infer actualSampleParams from actualOutput
	var actualSampleParams = sampleParamsPrior();
	var actualInput = observations.input;
	var actualStructureParams = observations.structureParams;
	var actualProgram = makeProgram(actualStructureParams);
	var actualReturnValues = actualProgram(actualInput, actualSampleParams);
	var actualOutput = actualReturnValues.output;
	var actualERPs = actualReturnValues.ERPs;
	condition(match(actualOutput, observations.output));

	// then sticky sample cfSampleParams
	var cfSampleParams = counterfactualizeLatents(
		sampleParamsPrior,
		actualSampleParams,
		stickiness
	);
	// and cfInput
	var cfInput = counterfactualizeLatents(
		inputPrior,
		actualInput,
		stickiness
	);
	// and cfStructureParams
	var cfStructureParams = counterfactualizeLatents(
		structureParamsPrior,
		actualStructureParams,
		stickiness
	);
	// and calculate corresponding output
	var cfProgram = makeProgram(cfStructureParams, actualStructureParams);
	var cfReturnValues = cfProgram(cfInput, cfSampleParams, actualInput, actualSampleParams);
	var cfOutput = cfReturnValues.output;

	// condition on cfPremise if applicable
	if (cfPremise) {
		condition(match(cfOutput, cfPremise));
	}

	// return cfOutput
	return cfOutput;
};

var inferSampleParams = cache(function(observations) {
	return Infer(
		{method: "MCMC", samples: 10000},
		function() {
			var sampleParams = sampleParamsPrior();
			var input = observations.input;
			var structureParams = observations.structureParams;
			var program = makeProgram(structureParams);
			var returnValues = program(input, sampleParams);
			var output = returnValues.output;
			condition(match(output, observations.output));
			return sampleParams;
		});
});

var counterfactualWithSubinference = function(stickiness, cfPremise) {

	// first infer actualSampleParams from actualOutput
	var actualSampleParams = sample(inferSampleParams(observations));
	var actualStructureParams = observations.structureParams;
	var actualInput = observations.input;
	var actualOutput = observations.output;

	// then sticky sample cfSampleParams
	var cfSampleParams = counterfactualizeLatents(
		sampleParamsPrior,
		actualSampleParams,
		stickiness
	);
	// and cfInput
	var cfInput = counterfactualizeLatents(
		inputPrior,
		actualInput,
		stickiness
	);
	// and cfStructureParams
	var cfStructureParams = counterfactualizeLatents(
		structureParamsPrior,
		actualStructureParams,
		stickiness
	);
	// and calculate corresponding output
	var cfProgram = makeProgram(cfStructureParams, actualStructureParams);
	var cfReturnValues = cfProgram(cfInput, cfSampleParams, actualInput, actualSampleParams);
	var cfOutput = cfReturnValues.output;

	// condition on cfPremise if applicable
	if (cfPremise) {
		condition(match(cfOutput, cfPremise));
	}

	// return cfOutput
	return cfOutput;
};

"finished";
