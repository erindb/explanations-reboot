// from MH: https://github.com/mhtess/generics/blob/master/models/node_modules/asymutils/asymutils.js

var eps = 0.000001;

// var inverseCDFMaxOverlap = function(erp, probability, origERP) {
//   // is value more or less probable in CF world?
//   var origsupp = origERP.support([]);
//   var supp = erp.support([]);
//   var cummulativeProbability = 0;
//   var origSampler = {};
//   for (var i=0; i<origsupp.length; i++) {
//     var s = origsupp[i];
//     var p = Math.exp(origERP.score(s));
//     var start = cummulativeProbability;
//     cummulativeProbability += p;
//     origSampler[s] = {
//       start: start,
//       end: cummulativeProbability,
//       p: p
//     };
//   }
//   var newSampler = [];
//   var openSpace = [];
//   var leftoverProbMass = [];
//   for (var i=0; i<supp.length; i++) {
//     var s = supp[i];
//     var p = Math.exp(erp.score(s));
//     var start = origSampler[s].start;
//     var origP = origSampler[s].p;
//     var origEnd = origSampler[s].end;
//     var end;
//     if (origP == p) {
//       end = origEnd;
//     } else if (origP < p) {
//       end = origEnd;
//       leftoverProbMass.push({ s: s, p: p - origP });
//     } else {
//       end = start + p;
//       openSpace.push({ start: end, end: end + (origP - p) });
//     }
//     newSampler.push(
//       {s: s, start: start, end: end}
//     );
//   }
//   // first double check that leftover prob mass == open space
//   var totalLeftoverProbMass = 0;
//   for (var i=0; i<leftoverProbMass.length; i++) {
//     totalLeftoverProbMass += leftoverProbMass[i].p;
//   }
//   var totalOpenSpace = 0;
//   for (var i=0; i<openSpace.length; i++) {
//     totalOpenSpace += (openSpace[i].end - openSpace[i].start);
//   }
//   if (totalOpenSpace-totalLeftoverProbMass > eps) {
//     console.log("error 2301 in utils.js sampling function");
//   }
//   // for each open space gap,
//   for (var i=0; i<openSpace.length; i++) {
//     // fill in a scaled version of leftover mass
//     var openSpaceToFill = openSpace[i];
//     var fillable = openSpaceToFill.end - openSpaceToFill.start;
//     var scaleFactor = fillable / totalLeftoverProbMass;
//     var startFillingInHere = openSpaceToFill.start;
//     for (var j=0; j<leftoverProbMass.length; j++) {
//       var leftoverMassToAdd = leftoverProbMass[j];
//       var s = leftoverMassToAdd.s;
//       var p = leftoverMassToAdd.p;
//       var scaledP = p*scaleFactor;
//       var start = startFillingInHere;
//       var end = start + scaledP;
//       startFillingInHere += scaledP;
//       newSampler.push({
//         s: s,
//         start: start,
//         end: end
//       });
//     }
//   }
//   for (var i=0; i<newSampler.length; i++) {
//     var start = newSampler[i].start;
//     var end = newSampler[i].end;
//     var s = newSampler[i].s;
//     if (start <= probability & probability <= end) {
//       return s;
//     }
//   }
//   // then fill in all open space with all probability mass
//   return s;
// }

// var inverseCDF = function(erp, probability) {
//   var supp = erp.support([]);
//   var cummulativeProbability = 0;
//   for (var i=0; i<supp.length; i++) {
//     var s = supp[i];
//     cummulativeProbability += Math.exp(erp.score(s));
//     if (probability<=cummulativeProbability) {
//       return s;
//     }
//   }
//   return s;
// };

// var origERPLog = {};

// var inverseCDFWithLog = function(erp, erpLabel, probability, currentLatents) {
//   var erpLookup = _.omit(currentLatents, "sampleParams");
//   var erpKey = JSON.stringify(erpLookup) + erpLabel;
//   origERPLog[erpKey] = erp;
//   return inverseCDF(erp, probability);
// };

// var inverseCDFMaxOverlapWithLookup = function(erp, erpLabel, probability, currentLatents, originalLatents) {
//   var erpLookup = _.omit(originalLatents, "sampleParams");
//   var erpKey = JSON.stringify(erpLookup) + erpLabel;
//   if (!origERPLog[erpKey]) {
//     console.log("error 2341: this actual erp was never sampled from");
//     stop
//   }
//   var origERP = origERPLog[erpKey];
//   return inverseCDFMaxOverlap(erp, probability, origERP);
// };

// function range(a,b,inc) {
//   return _.range(a, b, inc)
// }

function makeStickySamplingFunction(erp, origERP, erpLabel) {
  var erp = JSON.parse(erp);
  var origERP = JSON.parse(origERP);
  if (origERP) {
    var prob = _.object(erp.support, erp.probs);
    var origProb = _.object(origERP.support, origERP.probs);

    // collect elements with higher probability than in original ERP
    // and record how much more probability we need to account for
    var supportElemsWithHigherProb = {};
    var supportElemsWithHigherProbLst = [];
    var totalExtraProb = 0;
    for (var i=0; i<erp.support.length; i++) {
      var s = erp.support[i];
      if (prob[s] > origProb[s]) {
        totalExtraProb += prob[s] - origProb[s];
        supportElemsWithHigherProb[s] = prob[s] - origProb[s];
        supportElemsWithHigherProbLst.push(s);
      }
    }
    supportElemsWithHigherProb = _.mapObject(supportElemsWithHigherProb, function(val, key) {
      return val / totalExtraProb;
    });

    var newSupp = [];
    var newProbs = [];
    for (var i=0; i<origERP.support.length; i++) {
      var s = origERP.support[i];
      if (prob[s] >= origProb[s]) {
        // if element has equal or higher prob than original,
        // place element where it was in original ERP with
        // original ERP's prob (we'll fill the rest in later
        // from supportElemsWithHigherProb)
        newSupp.push(s);
        newProbs.push(origProb[s]);
      } else {
        // if element has lower prob than original,
        // go through supportElemsWithHigherProb to 
        // fill in extra space
        newSupp.push(s);
        newProbs.push(prob[s]);
        var remainingProbMass = origProb[s] - prob[s];
        for (var es = 0; es < supportElemsWithHigherProbLst.length; es++) {
          var extraS = supportElemsWithHigherProbLst[es];
          newSupp.push(extraS);
          newProbs.push(supportElemsWithHigherProb[extraS] * remainingProbMass);
        }
      }
    }

    // transform erp
    erp = {probs: newProbs, support: newSupp};

  }
  return function(s, k, a, sampleParam) {
    var cummulativeProbability = 0;
    for (var i=0; i<erp.support.length; i++) {
      cummulativeProbability += erp.probs[i];
      if (sampleParam < cummulativeProbability) {
        return k(s, erp.support[i]);
      }
    };
    console.log("warning 281: sampleParam < cummulativeProbability never happened.")
    return k(s, erp.support[i]);
  };
};

module.exports = {
  makeStickySamplingFunction: makeStickySamplingFunction
};