
// --------------------------- utils -------------------------------------------

var match = function(inferred, observed) {
	var overlappingKeys = _.object(map(function(k) {
		return [k, inferred[k]];
	}, _.keys(observed)));

	return _.isEqual(overlappingKeys, observed);
};

var reduce_to_matching_keys = function(bigger_object, limiting_object) {
	var overlappingKeys = _.object(map(function(k) {
		return [k, bigger_object[k]];
	}, _.keys(limiting_object)));
	return overlappingKeys;
};

var matchingFactor = function(interpretationERP, obs) {
	if (interpretationERP=="enumeration error") {
		return -Infinity;
	} else {
		// obs.input might have more keys than interpretationERP.input
		var reducedInterpretationERP = Infer(
			{method: "enumerate"},
			function() {
				var result = sample(interpretationERP);
				return {
					structureParams: result.structureParams,
					input: reduce_to_matching_keys(result.input, obs.input),
					output: result.output
				}
			}
		);
		// display(obs);
		// display(reducedInterpretationERP);
		return reducedInterpretationERP.score(obs);
	}
};

var cleanup = function(erp) {
	var all_false = reduce(
		function(s, acc) {
			var stillFalse = s.truthFactor == -Infinity;
			return acc && stillFalse;
		},
		true,
		erp.support()
	);
	if (all_false) {
		return "enumeration error";
	} 
	return Infer(
		{method: "enumerate"},
		function() {
			var s = sample(erp);
			factor(s.truthFactor);
			return s.observations;
		}
	);
};

// --------------------------- defaults ----------------------------------------

var defaults = {
	lambda1: 1,
	lambda2: 1,
	stickiness: 0.53,
	inferQUD: false,
	qud: "max",
	inferCG: false,
	cg: [],
	cgStates: {},
	inferLexicon: false,
	lexicon: "A",
	utteranceSet: "yes/no", // for s1
	inferenceOpts: {
		literal: {method: "enumerate"},
		s1: {method: "enumerate"},
		listener: {method: "enumerate"},
		s2: {method: "enumerate"}
	},
	interlocuter: "s1",
	costPerWord: 0
};

// --------------------------- counterfactuals logic ---------------------------

var counterfactualizeLatents = function(model, actual, stickiness) {
	var s = stickiness ? stickiness : 0.53;
	var totallyDifferent = model();

	return mapObject(function(key, value) {
		return flip(s) ? actual[key] : totallyDifferent[key];
	}, actual);
};

// --------------------------- forward sample ----------------------------------

var worldModel = function(params) {
	var params = params ? params : {};

	// forwardSample can sample both actual AND
	// counterfactual worlds. by default, it only
	// samples actual worlds.
	var returnCF = params.returnCF ? params.returnCF : false;

	// if we do return counterfactuals, we need to
	// decide on a stickiness parameter
	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);

	// by default, forward sample samples from the prior
	// and ignores all observations.
	// we can choose to condition on the observed
	// structureParams, input, and/or output.
	var useObs = params.useObs ? params.useObs : {
		structureParams: false,
		input: false,
		output: false
	};

	// observations can be specified for a specific
	// call to forwardSample. But in general, 
	// observations will be taken from the
	// observations.wppl file in `stories` directory,
	// defined in the `observations` variable in
	// `autoexpanded.wppl`.
	var obs = params.obs ? params.obs : observations;

	if (params.obs) {
		if (params.obs.structureParams && !useObs.structureParams) {
			display("warning 2340910928")
		}
		if (params.obs.input && !useObs.input) { display("warning 234013") }
		if (params.obs.input && !useObs.input) { display("warning 59834872") }
	}

	// we can also include counterfactual premises for
	// this function.
	var cfObs = params.cfObs ? params.cfObs : {};
	if (params.cfObs && !params.returnCF) { display("warning 2394810") }

	return function() {

		var structureParams = structureParamsPrior();
		var input = inputPrior();
		var sampleParams = sampleParamsPrior();

		var program = makeProgram(structureParams);
		var returnValues = program(input, sampleParams);
		var output = returnValues.output;
		var actualERPs = returnValues.ERPs;

		// condition on observations (maybe)
		if (useObs.structureParams) {
			condition(match(structureParams, obs.structureParams));
		}
		if (useObs.input) {
			condition(match(input, obs.input));
		}
		if (useObs.output) {
			condition(match(output, obs.output));
		}

		// return a world

		// only counterfactualize if we have to,
		// because it can be costly.
		if (returnCF) {

			// then sticky sample cfSampleParams
			var cfSampleParams = counterfactualizeLatents(
				sampleParamsPrior,
				sampleParams,
				stickiness
			);
			// and cfInput
			var cfInput = counterfactualizeLatents(
				inputPrior,
				input,
				stickiness
			);
			// and cfStructureParams
			var cfStructureParams = counterfactualizeLatents(
				structureParamsPrior,
				structureParams,
				stickiness
			);
			// and calculate corresponding output
			var cfProgram = makeProgram(cfStructureParams, actualERPs);
			var cfReturnValues = cfProgram(cfInput, cfSampleParams);
			var cfOutput = cfReturnValues.output;


			// condition on any counterfactual premises
			// (found in cfObs)
			if (cfObs.structureParams) {
				condition(match(cfStructureParams, cfObs.structureParams));
			}
			if (cfObs.input) {
				condition(match(cfInput, cfObs.input));
			}
			if (cfObs.output) {
				condition(match(cfOutput, cfObs.output));
			}

			return {
				structureParams: structureParams,
				input: input,
				output: output,
				cfStructureParams: cfStructureParams,
				cfInput: cfInput,
				cfOutput: cfOutput
			}
		} else {
			return {
				structureParams: structureParams,
				input: input,
				output: output,
			}
		}

		// TO DO: when sampleParams are relevant,
		// we might want to infer them and look at their
		// values.
	};
};

// --------------------------- utterance prior ---------------------------------

var utterancePriorMaker = function(params) {
	var params = params ? params : {};

	var utteranceSet = (
		params.utteranceSet ?
		params.utteranceSet :
		defaults.utteranceSet
	);
	var actualUtterance = (
		params.actualUtterance ? params.actualUtterance : false
	);

	var costPerWord = (
		params.costPerWord ? params.costPerWord : defaults.costPerWord
	);

	// for each base expression
	// we can say that expression
	var unaryUtterances = base_utterances.concat(
		// or we can negate it
		map(function(u) {return "! " + u;}, base_utterances)
	);

	var becauseUtterances = reduce(function(u1, acc) {
		return acc.concat(
			// because
			map(function (u2) {
				return u1 + " because " + u2;
			}, unaryUtterances))
	}, [], unaryUtterances);

	// logic for generating and and or sentences
	// not currently in use.
	var andUtterances = reduce(function(u1, acc) {
		return acc.concat(
			// and
			map(function (u2) {
				return u1 + " and " + u2;
			}, unaryUtterances)
		);
	}, [], unaryUtterances);

	var orUtterances = reduce(function(u1, acc) {
		return acc.concat(
			// and
			map(function (u2) {
				return u1 + " or " + u2;
			}, unaryUtterances)
		);
	}, [], unaryUtterances);

	// for each pair of unary expressions
	// we can say "and", "or", or "because"
	var binaryUtterances = becauseUtterances.concat(
		andUtterances.concat(orUtterances)
	);

	if (utteranceSet == "max") {
		// no dependence on actualUtterance
		var maxERP = Infer({method: "enumerate"}, function() {
			var utterance = uniformDraw(becauseUtterances.concat(["null"]));
			if (utterance!="null") {
				factor(- costPerWord * utterance.split(" ").length)
			}
			return utterance;
		});
		return function() {
			sample(maxERP);
		};
	} else {
		if (actualUtterance) {
			if (utteranceSet == "yes/no") {
				var yesnoERP = Infer({method: "enumerate"}, function() {
					var utterance = uniformDraw(["null", actualUtterance]);
					// for ":" prior type, that's yes/no and they're equally costly
					if (utterance!="null") {
						factor(- costPerWord * utterance.split(" ").length)
					}
					return utterance;
				});
				return function() {
					return sample(yesnoERP);
				};
			} else {
				display("warning 12341234")
			}
		} else {
			display("warning 2852")
		}
	}
};

var lookupUtterancePrior = cache(function(params) {
	return utterancePriorMaker(params);
});

// --------------------------- other priors ------------------------------------

var qudFns = {
	max: function(world) {return world}
	// TO DO other QUDs
};
var getCGStates = function(world, cg) {
	var asList = map(
	  function(variable) {return [variable, world[variable]];},
	  cg
	);
	return _.object(asList);
};

// TO DO
var qudPrior = function() {};
var cgPrior = function() {};
var lexiconPrior = function() {};

// --------------------------- RSA ---------------------------------------------

var meaning = function(params) {
	var params = params ? params : {};

	// return a factor (-Infinity, 0]
	// -Infinity corresponds to false
	// 0 corresponds to true

	var utterance = params.utterance;
	var world = params.world;

	var qud = params.qud ? params.qud : defaults.qud;
	var lexicon = params.lexicon ? params.lexicon : defaults.lexicon;
	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);

	// TO DO
	var qudFactor = "placeholder";

	return qudFactor;
};

var literal = function(params) {
	var params = params ? params : {};

	var utterance = params.utterance;

	var qud = params.qud ? params.qud : defaults.qud;
	var cgStates = params.cgStates ? params.cgStates : {};
	var lexicon = params.lexicon ? params.lexicon : defaults.lexicon;

	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);

	return function() {

		// sample an actual world
		// (note that counterfactual sampling happens inside meaning function)
		var world = (worldModel({}))();

		// condition on common ground
		condition(match(world.output, cgStates));

		var qudFn = qudFns[qud];

		// factor by meaning under the QUD
		var meaningFactor = meaning({
			utterance: utterance,
			world: world,
			qud: qud,
			lexicon: lexicon,
			stickiness: stickiness
		});
		factor(meaningFactor);

		return qudFn(world);
	};
};
var literalERP = cache(function(params) {
	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	return Infer(inferenceOpts.literal, literal(params));
});

var s1 = function(params) {
	var params = params ? params : {};

	// communicate the world, if provided. otherwise communicate
	// actual observations from experiment
	var world = params.world ? params.world : observations;

	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);

	var qud = params.qud ? params.qud : defaults.qud;
	var cgStates = params.cgStates ? params.cgStates : {};
	var lexicon = params.lexicon ? params.lexicon : defaults.lexicon;
	var utteranceSet = (
		params.utteranceSet ? params.utteranceSet : defaults.utteranceSet
	);
	var costPerWord = (
		params.costPerWord ? params.costPerWord : defaults.costPerWord
	);

	var lambda1 = params.lambda1 ? params.lambda1 : defaults.lambda1;
	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);
	var actualUtterance = (
		params.actualUtterance ? params.actualUtterance : false
	);

	return function() {

		var utterancePrior = lookupUtterancePrior({
			utteranceSet: utteranceSet,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		});
		var utterance = utterancePrior();

		// factor by interpretation
		var literalInterpretation = literalERP({
			inferenceOpts: inferenceOpts,
			utterance: utterance,
			qud: qud,
			cgStates: cgStates,
			lexicon: lexicon,
			stickiness: stickiness
		});

		// the speaker makes sure that their
 		// observations line up with interpretation
		var interpretationFactor = matchingFactor(
			literalInterpretation, world
		);
		factor(lambda1 * interpretationFactor);

		return utterance;
	};
};
var s1ERP = cache(function(params) {
	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	return Infer(inferenceOpts.s1, s1(params));
});

var listener = function(params) {
	var params = params ? params : {};

	var utterance = params.utterance;

	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);

	var lambda1 = params.lambda1 ? params.lambda1 : defaults.lambda1;
	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);
	var actualUtterance = (
		params.actualUtterance ? params.actualUtterance : false
	);
	var costPerWord = (
		params.costPerWord ? params.costPerWord : defaults.costPerWord
	);

	var inferQUD = params.inferQUD ? params.inferQUD : defaults.inferQUD;
	var inferCG = params.inferCG ? params.inferCG : defaults.inferCG;
	var inferLexicon = (
		params.inferLexicon ? params.inferLexicon : defaults.inferLexicon
	);

	var qud = inferQUD ? qudPrior() : (params.qud ? params.qud : defaults.qud);
	var cg = inferCG ? qudPrior() : (params.cg ? params.cg : defaults.cg);
	var lexicon = inferLexicon ? qudPrior() : (
		params.lexicon ? params.lexicon : defaults.lexicon
	);

	if (params.cg && params.inferCG) { display("warning 72913"); }
	if (params.qud && params.inferQUD) { display("warning 19482"); }
	if (params.lexicon && params.inferLexicon) { display("warning 73830427"); }

	return function() {

		// sample a world
		// note that counterfactual sampling happens inside meaning function
		var world = (worldModel({
			returnCF: false
		}))();

		var cgStates = getCGStates(world, cg);

		// factor by speaker
		var speakerEndorsement = s1ERP({
			inferenceOpts: inferenceOpts,
			world: world,
			qud: qud,
			cgStates: cgStates,
			lexicon: lexicon,
			lambda1: lambda1,
			stickiness: stickiness,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		});
		factor(speakerEndorsement.score(utterance));

		return world;
	};
};
var listenerERP = cache(function(params) {
	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	return Infer(inferenceOpts, listener(params));
});

var s2 = function(params) {
	var params = params ? params : {};

	// form the utterancePrior based on what was
	// actually said.
	var actualUtterance = params.actualUtterance;

	// observations can be specified with params.
	// But in general, 
	// observations will be taken from the
	// observations.wppl file in `stories` directory,
	// defined in the `observations` variable in
	// `autoexpanded.wppl`.
	var obs = params.obs ? params.obs : observations;

	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	var costPerWord = (
		params.costPerWord ? params.costPerWord : defaults.costPerWord
	);

	var inferQUD = params.inferQUD ? params.inferQUD : defaults.inferQUD;
	var inferCG = params.inferCG ? params.inferCG : defaults.inferCG;
	var inferLexicon = (
		params.inferLexicon ? params.inferLexicon : defaults.inferLexicon
	);

	var lambda1 = params.lambda1 ? params.lambda1 : defaults.lambda1;
	var lambda2 = params.lambda2 ? params.lambda2 : defaults.lambda2;
	var stickiness = (
		params.stickiness ? params.stickiness : defaults.stickiness
	);

	var qud = inferQUD ? qudPrior() : (params.qud ? params.qud : defaults.qud);
	var cg = inferCG ? qudPrior() : (params.cg ? params.cg : defaults.cg);
	var lexicon = inferLexicon ? qudPrior() : (
		params.lexicon ? params.lexicon : defaults.lexicon
	);

	if (params.cg && params.inferCG) { display("warning 72913"); }
	if (params.qud && params.inferQUD) { display("warning 19482"); }
	if (params.lexicon && params.inferLexicon) { display("warning 73830427"); }

	return function() {

		// utterancePrior for s2 is always "yes/no"
		var utterancePrior = lookupUtterancePrior({
			utteranceSet: "yes/no",
			actualUtterance: actualUtterance
		});
		var utterance = utterancePrior();

		// factor by interpretation
		var pragmaticInterpretation = listenerERP({
			inferenceOpts: inferenceOpts,
			utterance: utterance,
			qud: qud,
			cg: cg,
			lexicon: lexicon,
			inferQUD: inferQUD,
			inferCG: inferCG,
			inferLexicon: inferLexicon,
			lambda1: lambda1,
			stickiness: stickiness,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		});

		// TO DO
		// incorporate QUD

		// the speaker makes sure that their
 		// observations line up with interpretation
		var interpretationFactor = matchingFactor(
			pragmaticInterpretation, obs
		);
		factor(lambda2 * interpretationFactor);

		return utterance;
	}
};
var s2ERP = cache(function(params) {
	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	return Infer(inferenceOpts.s2, s2(params));
});

// --------------------------- BDA ---------------------------------------------

var lambda1Prior = function() {
	// see Tessler & Goodman 2016
	return uniform(0, 20);
};
var lambda2Prior = function() {
	// see Tessler & Goodman 2016
	return uniform(0, 5);
};
var stickinessPrior = function() {
	// uninformative prior between 0 and 1
	return uniform(0, 1);
};
var costPrior = function() {
	// TO DO
	// not sure what this should be
	return uniform(0, 10);
};
var model = function(params) {
	var params = params ? params : {};

	// specifies which listener/speaker model to run
	var interlocuter = (
		params.interlocuter ? params.interlocuter : defaults.interlocuter
	);
	var interlocuterLevel = [
		"literal", "s1", "listener", "s2"
	].indexOf(interlocuter);
	if (interlocuterLevel < 0) { display("warning 23409834") };

	// fixed parameters
	var inferenceOpts = (
		params.inferenceOpts ? params.inferenceOpts : defaults.inferenceOpts
	);
	var utteranceSet = (
		params.utteranceSet ? params.utteranceSet : defaults.utteranceSet
	);
	var qud = params.qud ? params.qud : defaults.qud;
	var cgStates = params.cgStates ? params.cgStates : defaults.cgStates;
	var lexicon = params.lexicon ? params.lexicon : defaults.lexicon;
	var inferQUD = params.inferQUD ? params.inferQUD : defaults.inferQUD;
	var inferCG = params.inferCG ? params.inferCG : defaults.inferCG;
	var inferLexicon = (
		params.inferLexicon ? params.inferLexicon : defaults.inferLexicon
	);
	var qud = inferQUD ? qudPrior() : (params.qud ? params.qud : defaults.qud);
	var cg = inferCG ? qudPrior() : (params.cg ? params.cg : defaults.cg);
	var lexicon = inferLexicon ? qudPrior() : (
		params.lexicon ? params.lexicon : defaults.lexicon
	);
	if (params.cg && params.inferCG) { display("warning 72913"); }
	if (params.qud && params.inferQUD) { display("warning 19482"); }
	if (params.lexicon && params.inferLexicon) { display("warning 73830427"); }

	// inferred parameters
	var lambda1 = interlocuterLevel > 0 ? lambda1Prior() : false;
	var lambda2 = interlocuterLevel > 2 ? lambda2Prior() : false;
	var stickiness = stickinessPrior();
	var costPerWord = interlocuterLevel > 0 ? costPrior() : false;
	var actualUtterance = (
		params.actualUtterance ? params.actualUtterance : false
	);

	if (interlocuter == "literal") {
		return literal({
			utterance: params.utterance,
			qud: qud,
			cgStates: cgStates,
			lexicon: lexicon,
			stickiness: stickiness
		});
	} else if (interlocuter == "s1") {
		return s1({
			inferenceOpts: inferenceOpts,
			world: params.world,
			qud: qud,
			cgStates: cgStates,
			lexicon: lexicon,
			lambda1: lambda1,
			stickiness: stickiness,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		});
	} else if (interlocuter == "listener") {
		return listener({
			inferenceOpts: inferenceOpts,
			utterance: params.utterance,
			qud: qud,
			cg: cg,
			lexicon: lexicon,
			inferQUD: inferQUD,
			inferCG: inferCG,
			inferLexicon: inferLexicon,
			lambda1: lambda1,
			stickiness: stickiness,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		})
	} else if (interlocuter == "s2") {
		return s2({
			inferenceOpts: inferenceOpts,
			world: params.world,
			qud: qud,
			cg: cg,
			lexicon: lexicon,
			inferQUD: inferQUD,
			inferCG: inferCG,
			inferLexicon: inferLexicon,
			lambda1: lambda1,
			lambda2: lambda2,
			stickiness: stickiness,
			actualUtterance: actualUtterance,
			costPerWord: costPerWord
		});
	}
};

//// -----------------------

// var conditionExplanansERP = cache(function(explanans, obs, actualSampleParams, actualERPs) {
// 	var explanansFalseVariable = explanans[0]=="!" ? true : false;
// 	var explanans = explanans[0]=="!" ? explanans[1] : explanans;
// 	return Infer(
// 		{method: "enumerate"},
// 		function() {
// 			// var cfPremise = {};
// 			// cfPremise[explanans] = false;
// 			// counterfactual(0.53, cfPremise, obs);

// 			var stickiness = 0.53;

// 			// now sticky sample cfSampleParams
// 			var cfSampleParams = counterfactualizeLatents(
// 				sampleParamsPrior,
// 				actualSampleParams,
// 				stickiness
// 			);
// 			// and cfInput
// 			var cfInput = counterfactualizeLatents(
// 				inputPrior,
// 				obs.input,
// 				stickiness
// 			);
// 			// and cfStructureParams
// 			var cfStructureParams = counterfactualizeLatents(
// 				structureParamsPrior,
// 				obs.structureParams,
// 				stickiness
// 			);

// 			// and calculate corresponding output
// 			var cfProgram = makeProgram(cfStructureParams, actualERPs);
// 			var cfReturnValues = cfProgram(cfInput, cfSampleParams);
// 			var cfOutput = cfReturnValues.output;

// 			// condition on the explanans variable having the
// 			// value that would make the explanans false
// 			condition(cfOutput[explanans]==explanansFalseVariable)

// 			// will the explanandum consequently be false??
// 			return cfOutput;
// 		}
// 	);
// });

// var getExplanandumFalseScore = function(explanandum, erp) {
// 	var explanandumFalseVariable = explanandum[0]=="!" ? true : false;
// 	var explanandumVariable = explanandum[0]=="!" ? explanandum[1] : explanandum;

// 	var marginal = Infer({method: "enumerate"}, function() {
// 		var s = sample(erp);
// 		return s[explanandumVariable] == explanandumFalseVariable;
// 	});
// 	return marginal.score(true);
// };

// var getScore = function(variable, erp) {
// 	var marginal = Infer({method: "enumerate"}, function() {
// 		var s = sample(erp);
// 		return s.variable == value;
// 	});
// 	return marginal.score(true);
// };

// var meaning = function(obs, utterance, actualSampleParams, actualERPs, entailmentType) {
// 	var entailmentType = entailmentType ? entailmentType : "none";

// 	var words = utterance.split(" ");
// 	if (utterance=="") {
// 		return 0;
// 	} else if (words.length==1) {
// 		var word = words[0];
// 		return (obs.output)[word] ? 0 : -Infinity;
// 	} else if (words.length==2 && words[0] == "!") {
// 		var word = words[1];
// 		return !(obs.output)[word] ? 0 : -Infinity;
// 	} else if (words.length>=3) {
// 		if (words.indexOf("and") > -1) {
// 			var phrase1 = words.slice(0, words.indexOf("and")).join("");
// 			var phrase2 = words.slice(words.indexOf("and")+1).join("");
// 			var TV1 = phrase1[0]=="!" ? !(obs.output)[phrase1[1]] : (obs.output)[phrase1];
// 			var TV2 = phrase2[0]=="!" ? !(obs.output)[phrase2[1]] : (obs.output)[phrase2];
// 			return TV1 && TV2 ? 0 : -Infinity;
// 		} else if (words.indexOf("or") > -1) {
// 			var phrase1 = words.slice(0, words.indexOf("or")).join("");
// 			var phrase2 = words.slice(words.indexOf("or")+1).join("");
// 			var TV1 = phrase1[0]=="!" ? !(obs.output)[phrase1[1]] : (obs.output)[phrase1];
// 			var TV2 = phrase2[0]=="!" ? !(obs.output)[phrase2[1]] : (obs.output)[phrase2];
// 			return TV1 || TV2 ? 0 : -Infinity;
// 		} else if (words.indexOf("because") > -1) {
// 			var explanandum = words.slice(0, words.indexOf("because")).join("");
// 			var explanans = words.slice(words.indexOf("because")+1).join("");
// 			var conditionedOnExplanansFalse = conditionExplanansERP(explanans, obs, actualSampleParams, actualERPs);
// 			var scoreExplanandumFalse = getExplanandumFalseScore(explanandum, conditionedOnExplanansFalse);
			
// 			var explanandumValue = explanandum[0]=="!" ? false : true;
// 			var explanandumVariable = explanandum[0]=="!" ? explanandum[1] : explanandum;
// 			var explanansValue = explanans[0]=="!" ? false : true;
// 			var explanansVariable = explanans[0]=="!" ? explanans[1] : explanans;
// 			var explanansScore = (obs.output)[explanansVariable]==explanansValue ? 0 : -Infinity;
// 			var explanandumScore = (obs.output)[explanandumVariable]==explanandumValue ? 0 : -Infinity;

// 			if (entailmentType == "none") {
// 				return scoreExplanandumFalse;
// 			} else if (entailmentType == "only_explanandum") {
// 				return scoreExplanandumFalse + explanandumScore;
// 			} else if (entailmentType == "only_explanans") {
// 				return scoreExplanandumFalse + explanansScore;
// 			} else if (entailmentType == "both") {
// 				return scoreExplanandumFalse + explanansScore + explanandumScore;
// 			} else {
// 				display("error 2349081");
// 			}
// 		}
// 		display("warning 21391")
// 		return 0;
// 	}
// 	display("warning 123");
// 	return 0;
// };


// var literal = function(utterance, entailmentType) {
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	return function() {
// 		// first sample actualSampleParams
// 		var actualSampleParams = sampleParamsPrior();
// 		var actualInput = inputPrior();
// 		var actualStructureParams = structureParamsPrior();
// 		var actualProgram = makeProgram(actualStructureParams);
// 		var actualReturnValues = actualProgram(actualInput, actualSampleParams);
// 		var actualOutput = actualReturnValues.output;
// 		var actualERPs = actualReturnValues.ERPs;
// 		var obs = {
// 			structureParams: actualStructureParams,
// 			input: actualInput,
// 			output: actualOutput
// 		}

// 		var truthFactor = meaning(obs, utterance, actualSampleParams, actualERPs, entailmentType);

// 		return {
// 			observations: obs,
// 			truthFactor: truthFactor
// 		};
// 	}
// };

// var literalERP = cache(function(utterance, entailmentType) {
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	return cleanup(Infer(
// 		{method: "enumerate"},
// 		literal(utterance, entailmentType)
// 	));
// });

// var projectObs = function(obs, QUD) {
// 	return obs[QUD];
// };
// var marginalize = function(erp, variable) {
// 	if (erp=="enumeration error") {
// 		return erp;
// 	} else {
// 		return Infer({method: "enumerate"}, function() {
// 			return (sample(erp))[variable];
// 		});
// 	}
// };

// var speaker = function(priorType, cost, explanandum, entailmentType, QUD, rationalityParam, obs) {

// 	// speaker might have observed anything
// 	var obs = obs ? obs : observations;
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	var rationalityParam = rationalityParam ? rationalityParam : 1;

// 	return function() {

// 		// they choose something to say
// 		var utterancePrior = possiblePriors(priorType, cost, explanandum);
// 		var utterance = utterancePrior();

// 		// the literal listener interprets this
// 		var interpretationERP = literalERP(utterance, entailmentType);

// 		var projectedInterpretation = QUD ? marginalize(interpretationERP, QUD) : interpretationERP;
// 		var projectedObs = QUD ? projectObs(obs, QUD) : obs;

// 		// the speaker makes sure that their
// 		// observations line up with interpretation
// 		var s = matchingFactor(projectedInterpretation, projectedObs);
// 		factor(rationalityParam * s);

// 		// and then they say it
// 		return {
// 			observations: utterance,
// 			truthFactor: s
// 		};
// 	};
// };

// var speakerERP = cache(function(priorType, cost, explanandum, entailmentType, QUD, rationalityParam, obs) {
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	return cleanup(Infer(
// 		{method: "enumerate"},
// 		speaker(priorType, cost, explanandum, entailmentType, QUD, rationalityParam, obs)
// 	));
// });

// var listener = function(utterance, cost, explanandum, rationalityParam, innerUtterancePriorType, entailmentType) {
// 	var entailmentType = entailmentType ? entailmentType : false;

// 	return function() {
// 		var actualSampleParams = sampleParamsPrior();
// 		var actualInput = inputPrior();
// 		var actualStructureParams = structureParamsPrior();
// 		var actualProgram = makeProgram(actualStructureParams);
// 		var actualReturnValues = actualProgram(actualInput, actualSampleParams);
// 		var actualOutput = actualReturnValues.output;
// 		var actualERPs = actualReturnValues.ERPs;
// 		var obs = {
// 			structureParams: actualStructureParams,
// 			input: actualInput,
// 			output: actualOutput
// 		};
// 		// var descriptionERP = speakerERP("all_alternatives", false, false, 1, obs);
// 		var descriptionERP = speakerERP(innerUtterancePriorType, cost, explanandum, entailmentType, false, rationalityParam, obs);

// 		var descriptionFactor = descriptionERP.score(utterance);

// 		return {
// 			observations: obs,
// 			truthFactor: descriptionFactor
// 		};
// 	};
// };

// var listenerERP = cache(function(utterance, cost, explanandum, rationalityParam, innerUtterancePriorType, entailmentType) {
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	var rationalityParam = rationalityParam ? rationalityParam : 1;
// 	return cleanup(Infer(
// 		{method: "enumerate"},
// 		listener(utterance, cost, explanandum, rationalityParam, innerUtterancePriorType, entailmentType)
// 	));
// });

// var s2 = function(base_utterance, cost, explanandum,
// 	innerUtterancePriorType, entailmentType,
// 	innerRationalityParam, outerRationalityParam) {
// 	var entailmentType = entailmentType ? entailmentType : "none";
// 	var QUD = false;
// 	var cost = cost ? cost : 0;
// 	var obs = observations;
// 	// "only_answers_to_why: " + explanandum
// 	var innerRationalityParam = innerRationalityParam ? innerRationalityParam : 1;
// 	var outerRationalityParam = outerRationalityParam ? outerRationalityParam : 1;

// 	return function() {
// 		var utterancePrior = possiblePriors(":" + base_utterance, cost, explanandum);
// 		var utterance = utterancePrior();

// 		// // the pragmatic listener interprets this
// 		// var interpretationERP = (
// 		// 	utterance == "" ? 
// 		// 	literalERP(utterance) :
// 		// 	listenerERP(utterance, innerRationalityParam, innerUtterancePriorType)
// 		// );
// 		var interpretationERP = (
// 			(innerUtterancePriorType=="varies") ? 
// 			(utterance=="" ? 
// 				literalERP(utterance) :
// 				listenerERP(utterance, cost, explanandum, innerRationalityParam, "fixed_explanandum")) :
// 			listenerERP(utterance, cost, explanandum, innerRationalityParam, innerUtterancePriorType, entailmentType)
// 		);

// 		var projectedInterpretation = QUD ? marginalize(interpretationERP, QUD) : interpretationERP;
// 		var projectedObs = QUD ? projectObs(obs, QUD) : obs;

// 		// the speaker makes sure that their
// 		// observations line up with interpretation
// 		var s = matchingFactor(projectedInterpretation, projectedObs);
// 		factor(outerRationalityParam * s);

// 		// and then they say it
// 		return utterance;
// 	};
// };

// // display(Infer({method: "enumerate"}, utterancePrior).support());

// // display(Infer({method: "enumerate"}, speaker));

"finished"
