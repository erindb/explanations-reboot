// -------- utils -------

var debug = function(string) {
	display(string);
};

var round = function(x){
  return Math.round(x*10)/10
};

var epsilon = 0.001;
var close = function(a, b) {
	return Math.abs(a-b) < epsilon;
};

var match = function(inferred, observed) {
	var overlapping = reduce_to_matching_keys(inferred, observed);
	return _.isEqual(overlapping, observed);
};

var reduce_to_matching_keys = function(bigger_object, limiting_object) {
	var keys = _.keys(limiting_object);
	var values = map(function(k) {
		return bigger_object[k];
	}, keys);
	var objWithOverlappingKeys = _.zipObject(keys, values);

	// then for each overlapping key, if its value is also an object,
	// reduce that, too.
	var reducedObject = mapObject(function(key, value) {
		// if it's an object
		var limiting_object_value = limiting_object[key];
		if (value !== null && typeof value === 'object') {
			var reduced_result = reduce_to_matching_keys(
				value, limiting_object_value
			);
			return reduced_result;
		} else if (close(value, limiting_object_value)) {
			// if we've got a number embedded in the bigger object,
			// then check if the number is close to that of the 
			// limiting object. if it is, give the reduced object
			// a chance to equal the limiting object (replace the
			// actual value with that of the limiting object)
			return limiting_object_value;
		} else {
			return value;
		}
	}, objWithOverlappingKeys);

	return reducedObject;
};

var matchingFactor = function(bigERP, obs) {
	if (bigERP=="enumeration error") {
		return -Infinity;
	} else {
		// obs.input might have more keys than interpretationERP.input
		var reducedERP = Infer(
			{method: "enumerate"},
			function() {
				var result = sample(bigERP);
				var reduced_result = reduce_to_matching_keys(result, obs);
				return reduced_result;
			}
		);
		return reducedERP.score(obs);
	}
};

var cleanupEnumerationOuput = function(erp) {
	var all_false = reduce(
		function(s, acc) {
			var stillFalse = s.truthFactor == -Infinity;
			return acc && stillFalse;
		},
		true,
		erp.support()
	);
	if (all_false) {
		return "enumeration error";
	} 
	return Infer(
		{method: "enumerate"},
		function() {
			var s = sample(erp);
			factor(s.truthFactor);
			return s.observations;
		}
	);
};

var marginalize = function(erp, variable) {
	if (erp=="enumeration error") {
		return erp;
	} else {
		return Infer({method: "enumerate"}, function() {
			return (sample(erp))[variable];
		});
	}
};

var filterKeys = function(object, keys) {
	var newKeys = filter(function(k) {
		return keys.indexOf(k)>=0;
	}, _.keys(object));
	var newValues = map(function(k) {
		return object[k];
	}, newKeys);
	return _.zipObject(newKeys, newValues);
};

var removeKeys = function(object, keys) {
	var newKeys = filter(function(k) {
		return keys.indexOf(k)<0;
	}, _.keys(object));
	var newValues = map(function(k) {
		return object[k];
	}, newKeys);
	return _.zipObject(newKeys, newValues);
};

// --------------------------- graphs logic ---------------------------

var variableSets = {
	lk1: ["A", "B"],
	lk2: ["A", "B", "C"]
};

var graphMaker = function(variables) {
	var all_pairs = reduce(function(v1, acc1) {
	  acc1.concat(reduce(function(v2, acc2) {
	    return (v1==v2 ? acc2 : acc2.concat([v1 + v2]));
	  }, [], variables));
	}, [], variables);

	var pairs = reduce(function(v1, acc1) {
	  acc1.concat(reduce(function(v2, acc2) {
	    return (v1>=v2 ? acc2 : acc2.concat([v1 + v2]));
	  }, [], variables));
	}, [], variables);

	var graphERP = Infer ({method: "enumerate"}, function() {
	  var graph = _.zipObject(
	    pairs,
	    map(function(pair) {
	      var linked = flip(2/3);
	      if (linked) {
	        return flip(0.5) ? ">" : "<";
	      } else { return "."; }
	    }, pairs)
	  );
	  // exclude cycles
	  if (graph["AB"]==graph["BC"] && graph["BC"]==graph["AC"]) {
	    factor( graph["AB"]=="." ? 0 : -Infinity );
	  }
	  return graph;
	})

	var all_possible_graphs = graphERP.support();
	return all_possible_graphs;
};

var getParentFn = cache(function(graph, label) {
	var variables = variableSets[label];
  return function (variable) {
    var v = variable;
    // variable v, e.g. "A"
    return filter(function(p) {
      // possible parent p, e.g. "B"
      if (v==p) {return false}
      var key = v<p ? v+p : p+v;
      // if v<p, then "<" corresponds to p being a parent
      // e.g. if v="A" and p="B", then v<p and so
      // "<" means p (B) is a parent of v (A).
      var dir = graph[key];
      if ((v<p && dir=="<") || (v>p && dir==">")) {
        return true
      } else {return false;}
    }, variables);
  };
});
var bg = function(p) {return function() {return flip(p);};};
var causeEnabled = function(p) {return function() {return flip(p);};};
var priors = {
	lk1: {
	  bA: bg(0.1),
	  bB: bg(0.1),
	  causeAB: causeEnabled(0.9),
	  causeBA: causeEnabled(0.9)
	},
	lk2: {
	  bA: bg(0.1),
	  bB: bg(0.1),
	  bC: bg(0.1),
	  causeAB: causeEnabled(0.75),
	  causeBA: causeEnabled(0.75),
	  causeBC: causeEnabled(0.75),
	  causeCB: causeEnabled(0.75),
	  causeAC: causeEnabled(0.75),
	  causeCA: causeEnabled(0.75)
	}
};
var getParamsPrior = function(graph, label) {
	var variables = variableSets[label];
  var parentFn = getParentFn(graph, label);
  var links = _.toPairs(graph);
  var causeParams = filter(function(x) {return x}, map(function(link) {
    var var1 = link[0][0];
    var var2 = link[0][1];
    var dir = link[1];
    if (dir == ">") {
      return "cause" + var1 + var2;
    } else if (dir == "<") {
      return "cause" + var2 + var1;
    } else {
      return false;
    }
  }, links));
  var backgroundParams = filter(function(x) {return x;}, map(function(v) {
    var parents = parentFn(v);
    if (parents.length == 0) {
      return "b" + v;
    } else {
      return false;
    }
  }, variables));
  var paramKeys = backgroundParams.concat(causeParams);
  return function() {
    return _.zipObject(
      paramKeys,
      map(function(pk) {
        var priorFn = priors[label][pk];
        return priorFn();
      }, paramKeys)
    );
  };
};
var getEvalFn = function(graph, params, label) {
	var parentFn = getParentFn(graph, label);
	var evaluate = function(varname) {
		var parents = parentFn(varname);
		if (parents.length==0) {
			return params["b" + varname];
		} else if (parents.length==1) {
			var parentValue = evaluate(parents[0]);
			var actualCause = params["cause" + parents[0] + varname];
			return parentValue&&actualCause;
		} else {
			var parentValue1 = evaluate(parents[0]);
			var parentValue2 = evaluate(parents[1]);
			var actualCause1 = params["cause" + parents[0] + varname];
			var actualCause2 = params["cause" + parents[1] + varname];
			return (
				(parentValue1&&actualCause1) ||
				(parentValue2&&actualCause2)
			);
		}
	};
	return evaluate;
};

// --------------------------- counterfactuals logic ---------------------------

var counterfactualizeLatents = function(model, actual, stickiness) {
	var s = stickiness ? stickiness : 0.53;
	var totallyDifferent = model();

	return mapObject(function(key, value) {
		return flip(s) ? actual[key] : totallyDifferent[key];
	}, actual);
};

// --------------------------- meaning fn -------------------------

var meaning = function(simpleUtterance, output) {
	// no because
	var variable = simpleUtterance[simpleUtterance.length-1];
	var value = output[variable];
	if (simpleUtterance[0]=="!") {
		return !value;
	} else {
		return value;
	}
};

var logicalIfMeaning = function(utterance, mainOutput, secondaryOutput) {
	if (utterance=="null") {return true;}
	var components = utterance.split(" because ");
	if (components.length==1) {
		meaning(utterance, mainOutput);
	} else {
		var explanans = components[1];
		var explanandum = components[0];
		// explanans or not explanandum
		return (
			meaning(explanans, secondaryOutput) ||
			! meaning(explanandum, secondaryOutput)
		);
	}
};

var nestedIfMeaning = function(utterance, graph, params) {
	var variables = ["A", "B"];
	var evalFn = getEvalFn(graph, params, "lk1");
	// calculate output (deterministic given graph and params)
	var output = _.zipObject(variables, map(evalFn, variables));

	if (utterance=="null") {return 0;}
		var components = utterance.split(" because ");
	if (components.length==1) {
		return meaning(utterance, output) ? 0 : -Infinity;
	} else {
		var explanans = components[1];
		var explanandum = components[0];

		// if !explanans then !explanandum
		var cfERP = Infer({method: "enumerate"}, function() {
			var paramsPrior = getParamsPrior(graph, "lk1");
			// counterfactualize params
			// RANDOM CHOICE
			var cfParams = counterfactualizeLatents(paramsPrior, params);

			var cfEvalFn = getEvalFn(graph, cfParams, "lk1");
			// calculate CF output (deteriministic given cfParams)
			var cfOutput = _.zipObject(variables, map(cfEvalFn, variables));

			condition(!meaning(explanans, cfOutput));

			return !meaning(explanandum, cfOutput);
		});
		return cfERP.score(true);
	}
};

// --------------------------- forward sample -------------------------

var lk1 = function() {
	var variables = ["A", "B"];

	var all_graphs = [{"AB":"."}, {"AB":"<"}, {"AB":">"}];

	// sample actual causal structure
	var graph = uniformDraw(all_graphs); // RANDOM CHOICE

	// sample situation parameters
	var paramsPrior = getParamsPrior(graph, "lk1");
	var params = paramsPrior(); // RANDOM CHOICE

	var evalFn = getEvalFn(graph, params, "lk1");
	// calculate output (deterministic given graph and params)
	var output = _.zipObject(variables, map(evalFn, variables));

	// counterfactualize params
	// RANDOM CHOICE
	var cfParams = counterfactualizeLatents(paramsPrior, params);

	var cfEvalFn = getEvalFn(graph, cfParams, "lk1");
	// calculate CF output (deteriministic given cfParams)
	var cfOutput = _.zipObject(variables, map(cfEvalFn, variables));

	return {
		actual: output,
		counterfactual: cfOutput,
		graph: graph
	};
};

var graphObj = {
	"no cause": {AB: ".", BC: ".", AC: "."},
	"A->B->C": {AB: ">", BC: ">", AC: "."},
	"A->B, C": {AB: ">", BC: ".", AC: "."},
	"B->A, C": {AB: "<", BC: ".", AC: "."},
	"A<-B->C": {AB: "<", BC: ">", AC: "."},
	"A, B->C": {AB: ".", BC: ">", AC: "."},
	"A, C->B": {AB: ".", BC: "<", AC: "."},
	"A->B<-C": {AB: ">", BC: "<", AC: "."},
	"A->C, B": {AB: ".", BC: ".", AC: ">"},
	"A->C<-B": {AB: ".", BC: ">", AC: ">"},
	"B<-A->C": {AB: ">", BC: ".", AC: ">"},
	"C->A, B": {AB: ".", BC: ".", AC: "<"},
	"C->A->B": {AB: ">", BC: ".", AC: "<"},
	"B->C->A": {AB: ".", BC: ">", AC: "<"}
};

// define alternative causal graphs
var str2graph = function(str) { return graphObj[str]; };
var abGraphs = _.map(str2graph, [
	"A, B->C", "A->B->C", "A<-B->C"
]);
var cbecausebGraphs = _.map(str2graph, [
	"A->B->C", "A->B, C", "A->B<-C", "A, C->B"
]);
var bbecausecGraphs = _.map(str2graph, [
	"A->B->C", "A->B, C", "A->B<-C"
]);
var acGraphs = _.map(str2graph, [
	"A, B, C", "A, B->C", "A->B, C",
	"C->A->B", "B->C->A", "C->A, B",
	"A->C<-B", "B<-A->C", "A->C, B"
]);

var relevant_graphs = {
	lk2: {
		"A because B": abGraphs,
		"B because A": abGraphs,
		"B because C": bbecausecGraphs,
		"C because B": cbecausebGraphs,
		"A because C": acGraphs,
		"C because A": acGraphs
	}
};

var lk2 = function(base_utterance) {

	var variables = ["A", "B", "C"];

	var all_graphs = relevant_graphs["lk2"][base_utterance];

	// sample actual causal structure
	var graph = uniformDraw(all_graphs); // RANDOM CHOICE

	// sample situation parameters
	var paramsPrior = getParamsPrior(graph, "lk2");
	var params = paramsPrior(); // RANDOM CHOICE

	var evalFn = getEvalFn(graph, params, "lk2");
	// calculate output (deterministic given graph and params)
	var output = _.zipObject(variables, map(evalFn, variables));

	// counterfactualize params
	// RANDOM CHOICE
	var cfParams = counterfactualizeLatents(paramsPrior, params);

	var cfEvalFn = getEvalFn(graph, cfParams, "lk2");
	// calculate CF output (deteriministic given cfParams)
	var cfOutput = _.zipObject(variables, map(cfEvalFn, variables));

	return {
		actual: output,
		counterfactual: cfOutput,
		graph: graph
	};
};

var identity = function(x) {return x;};
var extractActual = function(x) {return x.actual;};
var extractGraph = function(x) {return x.graph;};

var literalOptionsDefault = {
	QUD: identity,
	worldFn: lk1
};
var flat_literal = function(utterance, base_utterance, options) {
	var options = options ? options : {};
	var QUD = options.QUD ? options.QUD : literalOptionsDefault.QUD;
	var worldFn = (options.worldFn ?
		options.worldFn :
		literalOptionsDefault.worldFn
	);
	return function() {
		var world = worldFn(base_utterance);
		var output = world.actual;
		var cfOutput = world.counterfactual;
		var graph = world.graph;
		condition(logicalIfMeaning(utterance, output, cfOutput));
		return QUD(world);
	};
};
var nested_literal = function(utterance, options) {
	var variables = ["A", "B"];
	var options = options ? options : {};
	var QUD = options.QUD ? options.QUD : literalOptionsDefault.QUD;
	return function() {

		var all_graphs = [{"AB":"."}, {"AB":"<"}, {"AB":">"}];
		// sample actual causal structure
		var graph = uniformDraw(all_graphs); // RANDOM CHOICE

		// sample situation parameters
		var paramsPrior = getParamsPrior(graph, "lk1");
		var params = paramsPrior(); // RANDOM CHOICE

		var evalFn = getEvalFn(graph, params, "lk1");
		// calculate output (deterministic given graph and params)
		var output = _.zipObject(variables, map(evalFn, variables));

		factor(nestedIfMeaning(
			utterance,
			graph,
			params
		));

		return {
			output: output,
			graph: graph
		};
	};
};
var literal = flat_literal;

// --------------------------- utterance prior ---------------------------------

var uttPriorOptionsDefault = {
	costPerWord: 0,
	alternatives: "yes/no"
};
var utterancePriorMaker = cache(function(utterance, options) {
	var options = options ? options : {};
	var costPerWord = (
		options.costPerWord ?
		options.costPerWord :
		uttPriorOptionsDefault.costPerWord
	);
	var alternatives = (
		options.alternatives ?
		options.alternatives :
		uttPriorOptionsDefault.alternatives
	);
	if (alternatives=="yes/no") {
		var utterancePriorERP = Infer({method: "enumerate"}, function() {
			var u = uniformDraw([utterance, "null"]);
			if (u!="null") {
				var utteranceLength = (u.split(" ")).length;
				factor(-costPerWord * utteranceLength);
			}
			return u;
		});
		return function() {
			return sample(utterancePriorERP);
		};
	} else { display("error 947"); }
});

// --------------------------- s1 ---------------------------------

var s1OptionsDefault = {
	costPerWord: 0,
	alternatives: "yes/no",
	lambda1: 1,
	QUD: extractGraph,
	worldFn: lk1
};

var s1 = function(actualUtterance, actualWorld, options) {
	var options = options ? options : {};
	var QUD = options.QUD ? options.QUD : s1OptionsDefault.QUD;
	var lambda1 = (options.lambda1 ?
		options.lambda1 :
		s1OptionsDefault.lambda1
	);
	var worldFn = (options.worldFn ?
		options.worldFn :
		s1OptionsDefault.worldFn
	);
	var uttPriorOptions = reduce_to_matching_keys(options, uttPriorOptionsDefault);
	var utterancePrior = utterancePriorMaker(
		actualUtterance,
		uttPriorOptions
	);
	return function() {
		var utterance = utterancePrior();
		var interpretationERP = Infer({method: "enumerate"},
			literal(
				utterance,
				actualUtterance,
				_.extend(
					reduce_to_matching_keys(
						options,
						literalOptionsDefault
					),
					{QUD: QUD}
				)
			)
		);
		var interpretationScore = interpretationERP.score(actualWorld);
		factor(interpretationScore * lambda1);
		return utterance;
	};
};

// Infer({method: "enumerate"},
// 	literal("B because A", {
// 	QUD: identity,
// 	worldFn: lk2
// }));

