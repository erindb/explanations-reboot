// from MH: https://github.com/mhtess/generics/blob/master/models/node_modules/asymutils/asymutils.js

var eps = 0.000001;

var inverseCDFMaxOverlap = function(erp, probability, origERP) {
  // is value more or less probable in CF world?
  var origsupp = origERP.support([]);
  var supp = erp.support([]);
  var cummulativeProbability = 0;
  var origSampler = {};
  for (var i=0; i<origsupp.length; i++) {
    var s = origsupp[i];
    var p = Math.exp(origERP.score(s));
    var start = cummulativeProbability;
    cummulativeProbability += p;
    origSampler[s] = {
      start: start,
      end: cummulativeProbability,
      p: p
    };
  }
  var newSampler = [];
  var openSpace = [];
  var leftoverProbMass = [];
  for (var i=0; i<supp.length; i++) {
    var s = supp[i];
    var p = Math.exp(erp.score(s));
    var start = origSampler[s].start;
    var origP = origSampler[s].p;
    var origEnd = origSampler[s].end;
    var end;
    if (origP == p) {
      end = origEnd;
    } else if (origP < p) {
      end = origEnd;
      leftoverProbMass.push({ s: s, p: p - origP });
    } else {
      end = start + p;
      openSpace.push({ start: end, end: end + (origP - p) });
    }
    newSampler.push(
      {s: s, start: start, end: end}
    );
  }
  // first double check that leftover prob mass == open space
  var totalLeftoverProbMass = 0;
  for (var i=0; i<leftoverProbMass.length; i++) {
    totalLeftoverProbMass += leftoverProbMass[i].p;
  }
  var totalOpenSpace = 0;
  for (var i=0; i<openSpace.length; i++) {
    totalOpenSpace += (openSpace[i].end - openSpace[i].start);
  }
  if (totalOpenSpace-totalLeftoverProbMass > eps) {
    console.log("error 2301 in utils.js sampling function");
  }
  // for each open space gap,
  for (var i=0; i<openSpace.length; i++) {
    // fill in a scaled version of leftover mass
    var openSpaceToFill = openSpace[i];
    var fillable = openSpaceToFill.end - openSpaceToFill.start;
    var scaleFactor = fillable / totalLeftoverProbMass;
    var startFillingInHere = openSpaceToFill.start;
    for (var j=0; j<leftoverProbMass.length; j++) {
      var leftoverMassToAdd = leftoverProbMass[j];
      var s = leftoverMassToAdd.s;
      var p = leftoverMassToAdd.p;
      var scaledP = p*scaleFactor;
      var start = startFillingInHere;
      var end = start + scaledP;
      startFillingInHere += scaledP;
      newSampler.push({
        s: s,
        start: start,
        end: end
      });
    }
  }
  for (var i=0; i<newSampler.length; i++) {
    var start = newSampler[i].start;
    var end = newSampler[i].end;
    var s = newSampler[i].s;
    if (start <= probability & probability <= end) {
      return s;
    }
  }
  // then fill in all open space with all probability mass
  return s;
}

var inverseCDF = function(erp, probability) {
  var supp = erp.support([]);
  var cummulativeProbability = 0;
  for (var i=0; i<supp.length; i++) {
    var s = supp[i];
    cummulativeProbability += Math.exp(erp.score(s));
    if (probability<=cummulativeProbability) {
      return s;
    }
  }
  return s;
};

var origERPLog = {};

var inverseCDFWithLog = function(erp, probability, currentLatents) {
  var lookupLatents = _.omit(currentLatents, "samplingParameters");
  var erpKey = JSON.stringify(lookupLatents);
  origERPLog[erpKey] = erp;
  return inverseCDF(erp, probability);
};

var inverseCDFMaxOverlapWithLookup = function(erp, probability, currentLatents, originalLatents) {
  var origLookup = _.omit(originalLatents, "samplingParameters");
  var erpKey = JSON.stringify(origLookup);
  if (!origERPLog[erpKey]) {
    console.log("error 2341: this actual erp was never sampled from");
    stop
  }
  var origERP = origERPLog[erpKey];
  return inverseCDFMaxOverlap(erp, probability, origERP);
};

module.exports = {
  inverseCDF: inverseCDF,
  inverseCDFMaxOverlap: inverseCDFMaxOverlap,
  inverseCDFWithLog: inverseCDFWithLog,
  inverseCDFMaxOverlapWithLookup: inverseCDFMaxOverlapWithLookup
};